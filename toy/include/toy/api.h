/* Generated by gep (123/06/18 13:34:17) copyright (c) 2008 IRIT - UPS */
#ifndef GLISS_TOY_INCLUDE_TOY_API_H
#define GLISS_TOY_INCLUDE_TOY_API_H

#include <stdint.h>
#include <stdio.h>

#if defined(__WIN32) || defined(__WIN64)
#	ifdef __cplusplus
#		define __BEGIN_DECLS	extern "C" {
#		define __END_DECLS		}
#	else
#		define __BEGIN_DECLS
#		define __END_DECLS
#	endif
#else
#	include <sys/cdefs.h>
#endif

#include "id.h"
#include "mem.h"
#include "decode.h"

__BEGIN_DECLS

#define TOY_PROC_NAME "TOY"
#define TOY_PC_NAME  PC

/* return an instruction identifier as a string instead of the toy_ident_t which is not very user friendly */
char *toy_get_string_ident(toy_ident_t id);

/* opaque types */
typedef struct toy_platform_t toy_platform_t;
typedef struct toy_fetch_t toy_fetch_t;
typedef struct toy_decoder_t toy_decoder_t;
struct toy_loader_t;

/* toy_state_t type */
typedef struct toy_state_t {
	toy_platform_t *platform;
	uint16_t R[16];
	uint16_t PC;

	toy_memory_t *M;

} toy_state_t;

/* toy_sim_t type */
typedef struct toy_sim_t {
	toy_state_t *state;
	toy_decoder_t *decoder;
	/* on libc stripped programs it is difficult to find the exit point, so we specify it */
	toy_address_t addr_exit;
	/* anything else? */
	int ended;
} toy_sim_t;


/* toy_value_t type */
typedef union toy_value_t {
	int8_t int8;
	uint8_t uint8;

} toy_value_t;


/* toy_ii_t type */
typedef struct toy_ii_t {
	toy_value_t val;
} toy_ii_t;

/* toy_inst_t type */
typedef struct toy_inst_t {
	toy_ident_t   ident;
	toy_address_t addr;
	toy_ii_t instrinput[3];

} toy_inst_t;

/* auxiliary vector */
typedef struct toy_auxv_t {
	int	a_type;
	union {
		long a_val;
		void *a_ptr;
		void (*a_fcn)();
	} a_un;
} toy_auxv_t;

/* environment description */
typedef struct toy_env_t
{
	int argc;

	char **argv;
	toy_address_t argv_addr;

	char **envp;
	toy_address_t envp_addr;

	toy_auxv_t *auxv;
	toy_address_t auxv_addr;

	toy_address_t stack_pointer;
	toy_address_t brk_addr;
} toy_env_t;

/* platform management */
#define TOY_MAIN_MEMORY		0
toy_platform_t *toy_new_platform(void);
toy_memory_t *toy_get_memory(toy_platform_t *platform, int index);
struct toy_env_t;
struct toy_env_t *toy_get_sys_env(toy_platform_t *platform);
void toy_lock_platform(toy_platform_t *platform);
void toy_unlock_platform(toy_platform_t *platform);
int toy_load_platform(toy_platform_t *platform, const char *path);
void toy_load(toy_platform_t *platform, struct toy_loader_t *loader);

/* fetching */
toy_fetch_t *toy_new_fetch(toy_platform_t *pf);
void toy_delete_fetch(toy_fetch_t *fetch);


toy_ident_t toy_fetch(toy_fetch_t *fetch, toy_address_t address, uint16_t *code);

/* decoding */
typedef struct toy_mode_t {
	const char *name;
	toy_inst_t *(*decode)(toy_decoder_t *decoder, toy_address_t address);
} toy_mode_t;
extern toy_mode_t toy_modes[];

toy_decoder_t *toy_new_decoder(toy_platform_t *pf);
void toy_delete_decoder(toy_decoder_t *decoder);
toy_inst_t *toy_decode(toy_decoder_t *decoder, toy_address_t address);
void toy_free_inst(toy_inst_t *inst);
unsigned long toy_get_inst_size(toy_inst_t* inst);
unsigned long toy_get_inst_size_from_id(toy_ident_t id);


/* code execution */
void toy_execute(toy_state_t *state, toy_inst_t *inst);

/* state management function */
toy_state_t *toy_new_state(toy_platform_t *platform);
void toy_delete_state(toy_state_t *state);
toy_state_t *toy_copy_state(toy_state_t *state);
toy_state_t *toy_fork_state(toy_state_t *state);
void toy_dump_state(toy_state_t *state, FILE *out);
void toy_output_header_valid(FILE *out);
void toy_output_state_valid(toy_state_t *state, FILE *out);
toy_platform_t *toy_platform(toy_state_t *state);

/* simulation functions */
toy_sim_t *toy_new_sim(toy_state_t *state, toy_address_t start_addr, toy_address_t exit_addr);
toy_inst_t *toy_next_inst(toy_sim_t *sim);
uint64_t toy_run_and_count_inst(toy_sim_t *sim);
void toy_run_sim(toy_sim_t *sim);
void toy_step(toy_sim_t *sim);
void toy_delete_sim(toy_sim_t *sim);
toy_address_t  toy_next_addr(toy_sim_t *sim);
void toy_set_next_address(toy_sim_t *sim, toy_address_t address);
#define toy_set_entry_address(sim, addr) toy_set_next_address(sim, addr)
void toy_set_exit_address(toy_sim_t *sim, toy_address_t address);
#define toy_set_sim_ended(sim) (sim)->ended = 1
#define toy_is_sim_ended(sim) ((sim)->ended)

/* disassemble function */
void toy_disasm(char *buffer, toy_inst_t *inst);
typedef char *(*toy_label_solver_t)(toy_address_t address);
extern toy_label_solver_t toy_solve_label;
char *toy_solve_label_null(toy_address_t address);


__END_DECLS

#endif /* GLISS_TOY_INCLUDE_TOY_API_H */
