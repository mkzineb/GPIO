/* Generated by gep (123/06/18 13:34:17) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <toy/fetch.h>
#include <toy/decode.h> /* api.h will be in it, for fetch functions, decode_table.h also */
#include <toy/config.h> /* for memory endiannesses */

#include "decode_table.h"

#define toy_error(e) fprintf(stderr, "%s\n", (e))


/* external functions */
toy_ident_t toy_fetch(toy_fetch_t *fetch, toy_address_t address, uint16_t *code);


/* external tables */

/* decode structure */
struct toy_decoder_t
{
	/* the fetch unit used to retrieve instruction ID */
	toy_fetch_t *fetch;
};

/* Extern Modules */
/* Constants */
/* Variables & Fonctions */
/* decoding */
toy_inst_t *toy_decode(toy_decoder_t *decoder, toy_address_t address);


/* initialization and destruction of toy_decode_t object */
static int number_of_decoder_objects = 0;

static void init_decoder(toy_decoder_t *d, toy_platform_t *pf)
{
d->fetch = toy_new_fetch(pf);
}

static void halt_decoder(toy_decoder_t *d)
{
        toy_delete_fetch(d->fetch);
     
}

toy_decoder_t *toy_new_decoder(toy_platform_t *pf) {
	assert(pf);
    toy_decoder_t *res = malloc(sizeof(toy_decoder_t));
    if (res == NULL)
                toy_error("not enough memory to create a toy_decoder_t object"); /* I assume error handling will remain the same, we use toy_error istead of iss_error ? */
    init_decoder(res, pf);
    number_of_decoder_objects++;
    return res;
}

void toy_delete_decoder(toy_decoder_t *decode)
{
    if (decode == NULL)
        /* we shouldn't try to free a void decoder_t object, should this output an error ? */
                toy_error("cannot delete an NULL toy_decoder_t object");
    number_of_decoder_objects--;
    /*assert(number_of_decode_objects >= 0);*/
    halt_decoder(decode);
    free(decode);
    
}

/** set the state which is used to determine which instruction set we decode for,
 *  selection conditions are expressions using some state registers,
 *  the registers of the given state will be used after a call to this function.
 *  The fetch object will be created here for multi set descriptions.
 *  Does nothing if only one instr set is defined.
*/
void toy_set_cond_state(toy_decoder_t *decoder, toy_state_t *state) {
	assert(decoder);
	

}


/* Fonctions Principales */
toy_inst_t *toy_decode(toy_decoder_t *decoder, toy_address_t address)
{
	toy_inst_t *res = 0;
	toy_ident_t id;
	uint16_t code;

	/* first, fetch the instruction at the given address */
	id = toy_fetch(decoder->fetch, address, &code);
	
	/* then decode it */
	res = toy_decode_table[id](code);
	res->addr = address;
    
	return res;
}



/* End of file toy_decode.c */
