/* Generated by gep (123/06/18 13:34:17) copyright (c) 2008 IRIT - UPS */

#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <toy/mem.h>
#include <toy/fetch.h>

#include <toy/macros.h>
#include "fetch_table.h"

#define toy_error(e) fprintf(stderr, "%s\n", (e))


/**
 * Halt the fetch module.
 */
static void halt_fetch(void) {
}

/**
 * Initialize the fetch module.
 */
static void init_fetch(void) {
}



/**
 *  initialization and destruction of toy_fetch_t object
 */
static int number_of_fetch_objects = 0;


/**
 * Initialize a fetch handler.
 * @param pf	Current platform.
 * */
toy_fetch_t *toy_new_fetch(toy_platform_t *pf)
{
	toy_fetch_t *res = malloc(sizeof(toy_fetch_t));
	if (res == NULL)
		toy_error("not enough memory to create a toy_fetch_t object"); /* I assume error handling will remain the same, we use toy_error instead of iss_error ? */
	res->mem = toy_get_memory(pf, TOY_MAIN_MEMORY);
	if (number_of_fetch_objects == 0)
		init_fetch();
	number_of_fetch_objects++;
	return res;
}


/**
 * Delete the given fetch handler.
 * @param fetch		Fetch handler to delete.
 */
void toy_delete_fetch(toy_fetch_t *fetch)
{
	if (fetch == NULL)
		/* we shouldn't try to free a void fetch_t object, should this output an error ? */
		toy_error("cannot delete an NULL toy_fetch_t object");
	free(fetch);
	number_of_fetch_objects--;
	/*assert(number_of_fetch_objects >= 0);*/
	if (number_of_fetch_objects == 0)
		halt_fetch();
}

			
/**
 * Assemble bits representing the opcode.
 * @param	instr	Instruction work.
 * @param	mask	Mask of bits to group.
 * @return			Opcode.
 */
static uint16_t make_opcode16(uint16_t instr, uint16_t mask) {
	int i;
	uint16_t tmp_mask;
	uint16_t res = 0;

	tmp_mask = mask;
	for (i = 16 - 1; i >= 0; i--) {
		if (tmp_mask & 0x8000) {
			res <<= 1;
			res |= ((instr >> i) & 0x01);
		}
		tmp_mask <<= 1;
	}
	return res;
}


/**
 * Fetch the instruction at the given address.
 * @param fetch		Fetch handler.
 * @param address	Address to fetch from.
 * @param code		Bytes to store instruction code in.
 */
toy_ident_t toy_fetch(toy_fetch_t *fetch, toy_address_t address, uint16_t *code) {
	uint16_t valeur;
	Table_Decodage *ptr;
	Table_Decodage *ptr2 =toy_table;
	*code = toy_mem_read16(fetch->mem, address);
#	ifdef TOY_ORDER_BYTES16 
		{ uint8_t *buff = (uint8_t *)code; TOY_ORDER_BYTES16; }
#	endif
	do {
		valeur = make_opcode16(*code, ptr2->mask);
		ptr  = ptr2;
		ptr2 = ptr->table[valeur].ptr;
	} while(ptr->table[valeur].type == TABLEFETCH);
	return (toy_ident_t)ptr->table[valeur].ptr;
}




