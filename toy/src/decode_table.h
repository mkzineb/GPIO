/* Generated by gep (123/06/18 13:34:17) copyright (c) 2008 IRIT - UPS */

#ifndef GLISS_TOY_INCLUDE_TOY_DECODE_TABLE_H
#define GLISS_TOY_INCLUDE_TOY_DECODE_TABLE_H

#if defined(__cplusplus)
extern  "C"
{
#endif

#include <assert.h>
#include <toy/api.h>
#include <toy/macros.h>
#include <toy/gen_int.h>

#include <toy/mem.h>
#include <toy/grt.h>
#include <toy/error.h>
#include <toy/gen_int.h>
#include <toy/loader.h>
#include <toy/code.h>


/* TODO: add some error messages when malloc fails */
#define gliss_error(e) fprintf(stderr, "%s\n", (e))

/* hack : Enable cache if gep option is on 
(without having to  move decode.c to templates) */


/* decoder macros */
#define __EXTRACT(mask, offset_mask, inst)	  ( (uint16_t)((inst) & (mask)) >> (offset_mask))
#define __EXTS(mask, offset_mask, inst, n)    (((int16_t)__EXTRACT(mask, offset_mask, inst) << (16 - n)) >> (16 - n))
#define __EXT_SIGN(t, x, s)	((((t)(x)) << (s))>>(s)


static toy_inst_t *toy_instr_UNKNOWN_decode(uint16_t code_inst)
{
	toy_inst_t *inst = malloc(sizeof(toy_inst_t));
	inst->ident = TOY_UNKNOWN;

return inst;
}

/* beq %s, %s, %d */
static toy_inst_t *toy_instr_BEQ_S__S__D_decode(uint16_t code_inst) {

	
	toy_inst_t *inst = (toy_inst_t *)malloc(sizeof(toy_inst_t));
	inst->ident = TOY_BEQ_S__S__D;

	/* put other parameters */
	TOY_BEQ_S__S__D_x_r2_i = __EXTRACT(0x000000F0, 4, code_inst);
	TOY_BEQ_S__S__D_x_r1_i = __EXTRACT(0x00000F00, 8, code_inst);
	TOY_BEQ_S__S__D_x_off = __EXTS(0x0000000F, 0, code_inst, 3);

return inst;

}

/* add %s, %s, %s */
static toy_inst_t *toy_instr_ADD_S__S__S_decode(uint16_t code_inst) {

	
	toy_inst_t *inst = (toy_inst_t *)malloc(sizeof(toy_inst_t));
	inst->ident = TOY_ADD_S__S__S;

	/* put other parameters */
	TOY_ADD_S__S__S_x_s1_i = __EXTRACT(0x000000F0, 4, code_inst);
	TOY_ADD_S__S__S_x_d_i = __EXTRACT(0x00000F00, 8, code_inst);
	TOY_ADD_S__S__S_x_s2_i = __EXTRACT(0x0000000F, 0, code_inst);

return inst;

}

/* set %s, #%d */
static toy_inst_t *toy_instr_SET_S___ID_decode(uint16_t code_inst) {

	
	toy_inst_t *inst = (toy_inst_t *)malloc(sizeof(toy_inst_t));
	inst->ident = TOY_SET_S___ID;

	/* put other parameters */
	TOY_SET_S___ID_x_imm = __EXTRACT(0x000000FF, 0, code_inst);
	TOY_SET_S___ID_x_r_i = __EXTRACT(0x00000F00, 8, code_inst);

return inst;

}




typedef toy_inst_t *toy_decode_function_t(uint16_t code_inst);

static toy_decode_function_t *toy_decode_table[] =
{
	toy_instr_UNKNOWN_decode,
	toy_instr_BEQ_S__S__D_decode,
	toy_instr_ADD_S__S__S_decode,
	toy_instr_SET_S___ID_decode
};

/* free a dynamically allocated instruction, we try not to free an already freed or NULL pointer */
void toy_free_inst(toy_inst_t *inst) {
	assert(inst);
	// NB : inst->instrinput is allocate with the same malloc which allocate an instr

    /* finally free it */
	free(inst);
}

#if defined(__cplusplus)
}
#endif

#endif /* GLISS_TOY_INCLUDE_TOY_DECODE_TABLE_H */
